---
phase: 03-cli-tools-and-docker
plan: 02
type: execute
wave: 2
depends_on:
  - 03-01
files_modified:
  - scripts/install-tools.sh
autonomous: true
requirements:
  - TOOL-01
  - TOOL-02
  - TOOL-03
  - TOOL-04
  - TOOL-05
  - TOOL-06
  - TOOL-07

must_haves:
  truths:
    - "scripts/install-tools.sh exists with eight functions: install_ripgrep, install_fd, install_fzf, install_eza, install_bat, install_delta, install_nvim, and a helper _arch_for_tool"
    - "Each install function skips if the correct version is already installed, reinstalls if version differs, and respects DRY_RUN"
    - "Each install function handles x86_64 and arm64 architecture mapping correctly per the RESEARCH.md architecture mapping table"
    - "Flat archives (fzf, eza) and subdirectory archives (ripgrep, fd, bat, delta, nvim) are handled with the correct extraction paths"
    - "Each install function appends to _SUMMARY_INSTALLED or _SUMMARY_SKIPPED and writes to MANIFEST_FILE on success"
    - "Individual tool install failures are soft-fail (wrapped with || true equivalent) — one bad download does not abort all remaining installs"
  artifacts:
    - path: "scripts/install-tools.sh"
      provides: "Seven CLI tool installer functions"
      min_lines: 200
      contains: "install_ripgrep"
  key_links:
    - from: "scripts/install-tools.sh"
      to: "lib/versions.sh"
      via: "source ${DOTFILES_DIR}/lib/versions.sh"
      pattern: "source.*lib/versions\\.sh"
    - from: "install_ripgrep"
      to: "/usr/local/bin/rg"
      via: "install -m 755"
      pattern: "install -m 755.*rg"
    - from: "install_nvim"
      to: "/usr/local/bin/nvim"
      via: "install -m 755 .*/nvim-linux-.*/bin/nvim"
      pattern: "install -m 755.*nvim-linux"
---

<objective>
Create scripts/install-tools.sh with eight functions that install all seven CLI tools (ripgrep, fd, fzf, eza, bat, delta, neovim) from GitHub Releases for both x86_64 and ARM64 servers.

Purpose: This is the core of TOOL-01 through TOOL-07. Each function follows the canonical pattern established by install-gitleaks.sh — idempotency check, DRY_RUN support, architecture-aware tarball download, binary installation at /usr/local/bin, manifest entry, summary array append.

Output: scripts/install-tools.sh (~250 lines) with a reusable _arch_for_tool helper and seven install functions.
</objective>

<execution_context>
@/Users/elmartinez85/.claude/get-shit-done/workflows/execute-plan.md
@/Users/elmartinez85/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/03-cli-tools-and-docker/03-CONTEXT.md
@.planning/phases/03-cli-tools-and-docker/03-RESEARCH.md
@scripts/install-gitleaks.sh
@.planning/phases/03-cli-tools-and-docker/03-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create scripts/install-tools.sh with seven CLI tool installer functions</name>
  <files>scripts/install-tools.sh</files>
  <action>
Create scripts/install-tools.sh. Follow the exact structure of install-gitleaks.sh and install-shell.sh:

**File header:**
```bash
#!/usr/bin/env bash
# scripts/install-tools.sh
# Sourced by bootstrap.sh — provides install_ripgrep, install_fd, install_fzf,
# install_eza, install_bat, install_delta, install_nvim
# Do NOT execute directly.
# shellcheck source=lib/log.sh
# shellcheck source=lib/versions.sh
if [[ -n "${_SCRIPT_INSTALL_TOOLS_LOADED:-}" ]]; then return 0; fi
_SCRIPT_INSTALL_TOOLS_LOADED=1

# Source canonical version store — provides RIPGREP_VERSION, FD_VERSION, etc.
# shellcheck source=lib/versions.sh
source "${DOTFILES_DIR}/lib/versions.sh"
```

**Helper function _arch_for_tool:** Place before the install functions. Maps $ARCH (from os.sh: outputs "x86_64" or "arm64") to the tool-specific naming each project uses in their GitHub Release URLs. This is CRITICAL — getting this wrong causes a 404 at download time.

```bash
# Maps os.sh canonical ARCH (x86_64 or arm64) to tool-specific URL naming.
# Usage: local arch; arch="$(_arch_for_tool ripgrep)"
_arch_for_tool() {
  local tool="$1"
  case "$tool" in
    fzf)
      # fzf uses amd64/arm64 (not x86_64/aarch64)
      case "$ARCH" in x86_64) echo "amd64" ;; arm64) echo "arm64" ;; esac ;;
    eza|ripgrep|fd|bat|delta)
      # these use x86_64/aarch64
      case "$ARCH" in x86_64) echo "x86_64" ;; arm64) echo "aarch64" ;; esac ;;
    nvim|lazydocker)
      # nvim and lazydocker use x86_64/arm64 (matching $ARCH directly)
      echo "$ARCH" ;;
  esac
}
```

**Failure handling helper:** Wrap each install call in a soft-fail helper so one tool's download failure does not abort the entire bootstrap (set -eEuo pipefail is active in bootstrap.sh):

```bash
# Runs an install function. On failure: logs warning, appends to _SUMMARY_WARNINGS,
# continues. Docker Engine is NOT soft-failed (in install-docker.sh, not here).
_try_install() {
  local fn="$1"
  if ! "$fn"; then
    log_warn "WARNING: ${fn} failed — continuing bootstrap. Check logs."
    _SUMMARY_WARNINGS+=("${fn} failed — tool may not be available")
  fi
}
```

Note: bootstrap.sh will call `_try_install install_ripgrep` etc. rather than calling install functions directly. Document this in a comment near the helper.

**Seven install functions** — implement each following the canonical pattern from RESEARCH.md Pattern 1. Key per-tool differences (from the Architecture Mapping Table in RESEARCH.md):

**install_ripgrep:**
- URL pattern: `https://github.com/BurntSushi/ripgrep/releases/download/${version}/ripgrep-${version}-${arch}-unknown-linux-${libc}.tar.gz`
- x86_64: arch=`x86_64`, libc=`musl` → `ripgrep-{ver}-x86_64-unknown-linux-musl.tar.gz`
- arm64: arch=`aarch64`, libc=`gnu` → `ripgrep-{ver}-aarch64-unknown-linux-gnu.tar.gz`
- Tarball structure: subdirectory `ripgrep-{ver}-{arch}-unknown-linux-{libc}/rg`
- Install path: `/usr/local/bin/rg`
- Version check: `rg --version | head -1` contains version string

Since x86_64 uses musl and arm64 uses gnu, do NOT use _arch_for_tool for the libc suffix. Use a separate case statement:
```bash
local arch libc url
arch="$(_arch_for_tool ripgrep)"  # x86_64 or aarch64
case "$ARCH" in x86_64) libc="musl" ;; arm64) libc="gnu" ;; esac
url="https://github.com/BurntSushi/ripgrep/releases/download/${version}/ripgrep-${version}-${arch}-unknown-linux-${libc}.tar.gz"
local subdir="ripgrep-${version}-${arch}-unknown-linux-${libc}"
# extract then: install -m 755 "${tmpdir}/${subdir}/rg" "$install_path"
```

**install_fd:**
- URL pattern: `https://github.com/sharkdp/fd/releases/download/v${version}/fd-v${version}-${arch}-unknown-linux-${libc}.tar.gz`
- x86_64: arch=`x86_64`, libc=`musl`; arm64: arch=`aarch64`, libc=`gnu`
- Same libc split as ripgrep — use same case pattern
- Tarball structure: subdirectory `fd-v{ver}-{arch}-unknown-linux-{libc}/fd`
- Install path: `/usr/local/bin/fd`
- Version check: `fd --version | head -1`

**install_fzf:**
- URL pattern: `https://github.com/junegunn/fzf/releases/download/v${version}/fzf-${version}-linux_${fzf_arch}.tar.gz`
- x86_64: fzf_arch=`amd64`; arm64: fzf_arch=`arm64` (use _arch_for_tool fzf)
- Tarball structure: **FLAT** — binary `fzf` is directly in $tmpdir (no subdirectory)
- Install path: `/usr/local/bin/fzf`
- Version check: `fzf --version | head -1`

**install_eza:**
- URL pattern: `https://github.com/eza-community/eza/releases/download/v${version}/eza_${arch}-unknown-linux-gnu.tar.gz`
- x86_64: arch=`x86_64`; arm64: arch=`aarch64` (use _arch_for_tool eza)
- Tarball structure: **FLAT** — binary `./eza` directly in $tmpdir
- Install path: `/usr/local/bin/eza`
- Version check: `eza --version | head -1`

**install_bat:**
- URL pattern: `https://github.com/sharkdp/bat/releases/download/v${version}/bat-v${version}-${arch}-unknown-linux-${libc}.tar.gz`
- x86_64: arch=`x86_64`, libc=`musl`; arm64: arch=`aarch64`, libc=`gnu` — same libc split
- Tarball structure: subdirectory `bat-v{ver}-{arch}-unknown-linux-{libc}/bat`
- Install path: `/usr/local/bin/bat`
- Version check: `bat --version | head -1`

**install_delta:**
- URL pattern: `https://github.com/dandavison/delta/releases/download/${version}/delta-${version}-${arch}-unknown-linux-${libc}.tar.gz`
- x86_64: arch=`x86_64`, libc=`musl`; arm64: arch=`aarch64`, libc=`gnu` — same libc split
- NOTE: delta version has NO `v` prefix in the URL (unlike other tools) — use `${version}` not `v${version}`
- Tarball structure: subdirectory `delta-{ver}-{arch}-unknown-linux-{libc}/delta`
- Install path: `/usr/local/bin/delta`
- Version check: `delta --version | head -1`

**install_nvim:**
- URL pattern: `https://github.com/neovim/neovim/releases/download/v${version}/nvim-linux-${ARCH}.tar.gz`
- nvim uses $ARCH directly (x86_64 or arm64) — no arch mapping needed, _arch_for_tool returns $ARCH unchanged
- Tarball structure: subdirectory `nvim-linux-${ARCH}/bin/nvim`
- Install path: `/usr/local/bin/nvim`
- Version check: `nvim --version | head -1`
- IMPORTANT: Use tarball NOT AppImage — tarball requires no FUSE, works on headless servers (see STATE.md blocker and RESEARCH.md Pitfall 5)

**Each function must follow this structure** (see install-gitleaks.sh for the exact pattern):
1. `log_step "Checking {tool} ${version}..."`
2. Idempotency: if binary exists AND version matches → `_SUMMARY_SKIPPED+=(...)` return 0
3. DRY_RUN guard: `[[ "${DRY_RUN:-false}" == "true" ]] && { log_info "..."; return 0; }`
4. `local tmpdir; tmpdir="$(mktemp -d)"; trap 'rm -rf "$tmpdir"' RETURN`
5. `curl --fail --silent --show-error --location --retry 3 --retry-delay 2 "$url" | tar -xz -C "$tmpdir"`
6. `install -m 755 "${tmpdir}/${binary_path}" "$install_path"`
7. `log_success "{tool} ${version} installed at ${install_path}"`
8. `echo "file:${install_path}" >> "$MANIFEST_FILE"`
9. `_SUMMARY_INSTALLED+=("{tool} ${version}")`

For version check in idempotency step, use `"$install_path" --version 2>/dev/null | head -1 || echo "unknown"` and check `[[ "$installed_ver" == *"${version}"* ]]`.
  </action>
  <verify>
bash -n scripts/install-tools.sh && echo "Syntax OK" && grep -c "^install_" scripts/install-tools.sh | xargs -I{} bash -c '[[ {} -eq 7 ]] && echo "7 install functions found"'
  </verify>
  <done>
scripts/install-tools.sh exists. bash -n passes. File contains exactly 7 functions named install_ripgrep, install_fd, install_fzf, install_eza, install_bat, install_delta, install_nvim plus _arch_for_tool helper and _try_install soft-fail wrapper. Each function has idempotency check, DRY_RUN guard, architecture mapping, trap-based tmpdir cleanup, binary install via `install -m 755`, manifest entry, and summary array append.
  </done>
</task>

</tasks>

<verification>
1. `bash -n scripts/install-tools.sh` — no syntax errors
2. `grep -c "^install_" scripts/install-tools.sh` returns 7
3. `grep "_arch_for_tool" scripts/install-tools.sh` — helper exists
4. `grep "_try_install" scripts/install-tools.sh` — soft-fail wrapper exists
5. `grep "DRY_RUN" scripts/install-tools.sh | wc -l` — DRY_RUN guards present in multiple functions
6. `grep "trap.*RETURN" scripts/install-tools.sh | wc -l` — 7 trap-based tmpdir cleanups
7. `grep "MANIFEST_FILE" scripts/install-tools.sh | wc -l` — 7 manifest entries
8. `grep "nvim-linux-\${ARCH}/bin/nvim" scripts/install-tools.sh` — tarball path correct for nvim
9. `grep "fzf.*amd64\|amd64.*fzf" scripts/install-tools.sh` — fzf uses amd64 for x86_64
</verification>

<success_criteria>
scripts/install-tools.sh is a syntactically valid bash file with 7 install functions, correct architecture mapping per the RESEARCH.md table, correct tarball extraction paths for both flat and subdirectory archives, idempotency, DRY_RUN support, soft-fail wrapper, manifest entries, and summary array appends.
</success_criteria>

<output>
After completion, create `.planning/phases/03-cli-tools-and-docker/03-02-SUMMARY.md`
</output>
