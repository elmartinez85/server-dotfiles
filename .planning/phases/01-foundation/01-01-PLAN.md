---
phase: 01-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - .gitignore
  - lib/log.sh
  - lib/os.sh
  - lib/pkg.sh
  - config/.gitkeep
  - scripts/.gitkeep
autonomous: true
requirements:
  - BOOT-02
  - BOOT-03

must_haves:
  truths:
    - "Repo directory structure (lib/, scripts/, config/, hooks/) exists and is committed"
    - "lib/log.sh provides log_info, log_success, log_warn, log_error, log_step with color-coded TTY-safe output and dual terminal+file output via tee"
    - "lib/os.sh provides os_detect_arch() that normalizes x86_64 and aarch64/arm64 to canonical values"
    - "lib/pkg.sh provides idempotent pkg_install wrapper around apt"
    - "All lib/*.sh files use double-source guards and prefixed function namespaces"
    - ".gitignore prevents .installed manifest and bootstrap.log from being committed"
  artifacts:
    - path: "lib/log.sh"
      provides: "Logging functions: log_info, log_success, log_warn, log_error, log_step"
      min_lines: 30
    - path: "lib/os.sh"
      provides: "OS/arch detection: os_detect_arch, os_require_root"
      min_lines: 20
    - path: "lib/pkg.sh"
      provides: "Package helpers: pkg_installed, pkg_install"
      min_lines: 20
    - path: ".gitignore"
      provides: "Excludes .installed manifest and bootstrap.log"
      contains: ".installed"
  key_links:
    - from: "bootstrap.sh (future plan)"
      to: "lib/log.sh"
      via: "source ${DOTFILES_DIR}/lib/log.sh"
      pattern: "source.*lib/log\\.sh"
    - from: "bootstrap.sh (future plan)"
      to: "lib/os.sh"
      via: "source ${DOTFILES_DIR}/lib/os.sh"
      pattern: "source.*lib/os\\.sh"
---

<objective>
Create the repo skeleton and shared bash libraries that all bootstrap scripts depend on.

Purpose: This is the foundational layer — every subsequent script sources these libs. Getting the structure and library contracts right here prevents rework in all later plans.
Output: Directory structure (lib/, scripts/, config/, hooks/), three sourced lib files (log.sh, os.sh, pkg.sh), and .gitignore.
</objective>

<execution_context>
@/Users/elmartinez85/.claude/get-shit-done/workflows/execute-plan.md
@/Users/elmartinez85/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create repo skeleton and .gitignore</name>
  <files>
    .gitignore
    config/.gitkeep
    scripts/.gitkeep
  </files>
  <action>
Create the directory structure and .gitignore for the repo.

1. Create directories (all at repo root):
   - `lib/` — sourced helper libraries (files created in Task 2)
   - `scripts/` — executable phase scripts; add `scripts/.gitkeep` to track empty dir
   - `config/` — dotfiles/config files; add `config/.gitkeep` to track empty dir
   - `hooks/` — source-controlled git hook scripts (file created in Plan 03)

2. Create `.gitignore` at repo root with these entries:
   ```
   # Bootstrap runtime files
   .installed
   bootstrap.log

   # OS/editor artifacts
   .DS_Store
   *.swp
   *~
   ```

The `lib/` and `hooks/` directories will be populated by files in Tasks 2 and Plan 03 respectively — no .gitkeep needed since they'll have content.
  </action>
  <verify>
    ls -la scripts/ config/ lib/ hooks/ 2>/dev/null || echo "MISSING DIRS"
    cat .gitignore | grep ".installed"
  </verify>
  <done>
    - directories scripts/, config/, lib/, hooks/ all exist
    - .gitignore exists at repo root and contains .installed and bootstrap.log entries
  </done>
</task>

<task type="auto">
  <name>Task 2: Create shared bash libraries (log.sh, os.sh, pkg.sh)</name>
  <files>
    lib/log.sh
    lib/os.sh
    lib/pkg.sh
  </files>
  <action>
Create three sourced library files in `lib/`. Each file MUST:
- Use `#!/usr/bin/env bash` shebang (portability over `/bin/bash`)
- Start with a double-source guard using a prefixed variable
- Use prefixed function names matching the file (log_, os_, pkg_)
- Use `local` for all internal variables

**lib/log.sh** — Logging with color-coded TTY-safe output:
```bash
#!/usr/bin/env bash
if [[ -n "${_LIB_LOG_LOADED:-}" ]]; then return 0; fi
_LIB_LOG_LOADED=1

# Color codes — only emit when stdout is a terminal
if [[ -t 1 ]]; then
  _RED="\033[0;31m"
  _GREEN="\033[0;32m"
  _YELLOW="\033[0;33m"
  _BLUE="\033[0;34m"
  _BOLD="\033[1m"
  _RESET="\033[0m"
else
  _RED="" _GREEN="" _YELLOW="" _BLUE="" _BOLD="" _RESET=""
fi

log_info()    { echo -e "${_BLUE}  [INFO]${_RESET} $*"; }
log_success() { echo -e "${_GREEN}  ✓ ${_RESET} $*"; }
log_warn()    { echo -e "${_YELLOW}  [WARN]${_RESET} $*"; }
log_error()   { echo -e "${_RED}  [ERROR]${_RESET} $*" >&2; }
log_step()    { echo -e "\n${_BOLD}==> $*${_RESET}"; }
```

Note: Do NOT set up `tee` redirection inside log.sh. That belongs in bootstrap.sh (the entrypoint). log.sh only defines the log_* functions.

**lib/os.sh** — OS and architecture detection:
```bash
#!/usr/bin/env bash
if [[ -n "${_LIB_OS_LOADED:-}" ]]; then return 0; fi
_LIB_OS_LOADED=1

# Source log lib if not already loaded (guard prevents double-source)
_OS_SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# shellcheck source=lib/log.sh
source "${_OS_SCRIPT_DIR}/log.sh"

os_detect_arch() {
  local raw
  raw="$(uname -m)"
  case "$raw" in
    x86_64)         echo "x86_64" ;;
    aarch64|arm64)  echo "arm64"  ;;
    *)
      log_error "Unsupported architecture: ${raw}. Supported: x86_64, aarch64/arm64"
      return 1
      ;;
  esac
}

os_require_root() {
  if [[ "${EUID:-$(id -u)}" -ne 0 ]]; then
    log_error "This script must be run as root (or via sudo)."
    log_error "Re-run: sudo bash bootstrap.sh"
    exit 1
  fi
}
```

Note on aarch64|arm64: Linux ARM64 servers return `aarch64`; macOS ARM returns `arm64`. Both map to `arm64` — the naming used by gitleaks and other GitHub Releases binaries. Always handle both in the same case branch.

**lib/pkg.sh** — Idempotent apt package helpers:
```bash
#!/usr/bin/env bash
if [[ -n "${_LIB_PKG_LOADED:-}" ]]; then return 0; fi
_LIB_PKG_LOADED=1

_PKG_SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# shellcheck source=lib/log.sh
source "${_PKG_SCRIPT_DIR}/log.sh"

# Check if a package is installed (via dpkg)
pkg_installed() {
  local pkg="$1"
  dpkg-query -W -f='${Status}' "$pkg" 2>/dev/null | grep -q "install ok installed"
}

# Idempotent apt install — skips if already installed
pkg_install() {
  local pkg="$1"
  if pkg_installed "$pkg"; then
    log_info "${pkg} already installed — skipping"
    return 0
  fi
  log_step "Installing ${pkg}..."
  if [[ "${DRY_RUN:-false}" == "true" ]]; then
    log_info "[DRY RUN] Would run: apt-get install -y ${pkg}"
    return 0
  fi
  apt-get install -y "$pkg"
  log_success "${pkg} installed"
}
```
  </action>
  <verify>
    bash -n lib/log.sh && echo "log.sh: syntax OK"
    bash -n lib/os.sh && echo "os.sh: syntax OK"
    bash -n lib/pkg.sh && echo "pkg.sh: syntax OK"
    bash -c 'source lib/log.sh; log_info "test"' && echo "log.sh: sources OK"
    bash -c 'source lib/os.sh; os_detect_arch' && echo "os.sh: arch=$(bash -c 'source lib/os.sh; os_detect_arch')"
  </verify>
  <done>
    - All three lib files exist and pass bash -n syntax check
    - lib/log.sh sources cleanly and log_info produces output
    - lib/os.sh sources cleanly and os_detect_arch returns x86_64 or arm64 without error
    - lib/pkg.sh sources cleanly
    - Double-source guards present in all three files (grep _LIB_LOG_LOADED lib/log.sh, etc.)
  </done>
</task>

</tasks>

<verification>
Run from repo root:
1. `bash -n lib/log.sh lib/os.sh lib/pkg.sh` — all pass syntax check
2. `bash -c 'source lib/log.sh; log_step "Phase 1 test"; log_success "OK"'` — produces colored output
3. `bash -c 'source lib/os.sh; echo "Arch: $(os_detect_arch)"'` — prints Arch: x86_64 or Arch: arm64
4. `cat .gitignore | grep -E "\.installed|bootstrap\.log"` — both entries present
5. `ls lib/ scripts/ config/ hooks/` — all four directories exist
</verification>

<success_criteria>
- lib/log.sh, lib/os.sh, lib/pkg.sh all exist, pass `bash -n`, and source without error
- os_detect_arch() returns the correct architecture for the current machine
- .gitignore excludes .installed and bootstrap.log
- All four directories (lib/, scripts/, config/, hooks/) exist
- Double-source guards and prefixed function namespaces confirmed in all lib files
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-01-SUMMARY.md` with:
- Files created and their exported function signatures
- Architecture detection output on the build machine
- Any deviations from the plan and why
</output>
