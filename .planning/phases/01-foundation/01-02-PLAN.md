---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on:
  - "01-01"
files_modified:
  - bootstrap.sh
autonomous: true
requirements:
  - BOOT-01
  - BOOT-02
  - BOOT-03

must_haves:
  truths:
    - "bootstrap.sh exists at repo root and is executable"
    - "Running bootstrap.sh --dry-run on a fresh machine prints what would happen without making changes"
    - "Running bootstrap.sh a second time on an already-bootstrapped machine completes without error (idempotent)"
    - "bootstrap.sh detects x86_64 and ARM64 architectures and exports ARCH"
    - "On failure, bootstrap.sh reads ~/.dotfiles/.installed in reverse order and undoes all recorded actions from all prior runs"
    - "All output goes to both terminal and ~/.dotfiles/bootstrap.log via tee"
    - "A full run summary is printed at the end: installed, skipped, and any warnings"
  artifacts:
    - path: "bootstrap.sh"
      provides: "curl | bash entrypoint — clones repo, sources libs, runs phase scripts, handles cleanup"
      min_lines: 80
      exports: []
  key_links:
    - from: "bootstrap.sh"
      to: "lib/log.sh"
      via: "source ${DOTFILES_DIR}/lib/log.sh"
      pattern: "source.*lib/log\\.sh"
    - from: "bootstrap.sh"
      to: "lib/os.sh"
      via: "source ${DOTFILES_DIR}/lib/os.sh"
      pattern: "source.*lib/os\\.sh"
    - from: "bootstrap.sh"
      to: "lib/pkg.sh"
      via: "source ${DOTFILES_DIR}/lib/pkg.sh"
      pattern: "source.*lib/pkg\\.sh"
    - from: "bootstrap.sh"
      to: "~/.dotfiles/.installed"
      via: "manifest file read in cleanup()"
      pattern: "MANIFEST_FILE.*\\.installed"
---

<objective>
Create bootstrap.sh — the `curl | bash` entrypoint that clones the repo and orchestrates the full setup sequence.

Purpose: This is the single command users run on a fresh server. It must handle first-run clone, idempotent re-runs, arch detection, fail-fast error handling with full manifest-based cleanup, --dry-run mode, dual output (terminal + log file), and an end-of-run summary.
Output: bootstrap.sh at repo root, executable, fully functional entrypoint.
</objective>

<execution_context>
@/Users/elmartinez85/.claude/get-shit-done/workflows/execute-plan.md
@/Users/elmartinez85/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create bootstrap.sh entrypoint</name>
  <files>
    bootstrap.sh
  </files>
  <action>
Create `bootstrap.sh` at the repo root. This is the `curl <url>/bootstrap.sh | bash` target.

**Critical constraints from research (enforce all):**
- `#!/usr/bin/env bash` shebang (not `#!/bin/bash`)
- `set -eEuo pipefail` at top — `-E` propagates ERR traps into functions, `-u` catches unset vars, `pipefail` catches pipe failures
- `trap cleanup EXIT` (not just ERR) — check `$?` inside cleanup to distinguish success from failure
- Never use `read` or interactive prompts — stdin may be a pipe (curl | bash)
- `tee` redirection in bootstrap.sh, NOT in lib/log.sh
- Colors only via log functions from lib/log.sh (TTY-safe already handled there)
- Manifest at `~/.dotfiles/.installed` (persists across runs, gitignored)
- `uname -m` case statement via `os_detect_arch` from lib/os.sh

**Structure:**

```bash
#!/usr/bin/env bash
# bootstrap.sh — Usage: curl <url>/bootstrap.sh | bash
# Or with dry-run: curl <url>/bootstrap.sh | bash -s -- --dry-run
set -eEuo pipefail

# ── Constants ────────────────────────────────────────────────────────────────
DOTFILES_REPO="https://github.com/<YOUR_GITHUB_USER>/server-dotfiles.git"
DOTFILES_DIR="${HOME}/.dotfiles"
LOG_FILE="${DOTFILES_DIR}/bootstrap.log"
MANIFEST_FILE="${DOTFILES_DIR}/.installed"

# ── Flags ────────────────────────────────────────────────────────────────────
DRY_RUN=false
for arg in "$@"; do
  case "$arg" in
    --dry-run) DRY_RUN=true ;;
  esac
done
export DRY_RUN

# ── Bootstrap summary tracking ───────────────────────────────────────────────
_SUMMARY_INSTALLED=()
_SUMMARY_SKIPPED=()
_SUMMARY_WARNINGS=()

# ── Repo clone (before libs can be sourced) ───────────────────────────────────
if [[ ! -d "${DOTFILES_DIR}/.git" ]]; then
  echo "==> Cloning server-dotfiles to ${DOTFILES_DIR}..."
  git clone "$DOTFILES_REPO" "$DOTFILES_DIR"
else
  echo "==> ${DOTFILES_DIR} already exists — pulling latest..."
  git -C "$DOTFILES_DIR" pull --ff-only || true
fi

# ── Source libs ───────────────────────────────────────────────────────────────
# shellcheck source=lib/log.sh
source "${DOTFILES_DIR}/lib/log.sh"
# shellcheck source=lib/os.sh
source "${DOTFILES_DIR}/lib/os.sh"
# shellcheck source=lib/pkg.sh
source "${DOTFILES_DIR}/lib/pkg.sh"

# ── Logging setup — dual output to terminal and log file ─────────────────────
mkdir -p "$(dirname "$LOG_FILE")"
exec > >(tee -a "$LOG_FILE") 2>&1

# ── Cleanup / rollback function ────────────────────────────────────────────────
cleanup() {
  local exit_code=$?
  if [[ $exit_code -ne 0 ]]; then
    log_error "Bootstrap failed (exit ${exit_code}). Reverting all installed state..."
    if [[ -f "$MANIFEST_FILE" ]]; then
      local steps=()
      mapfile -t steps < "$MANIFEST_FILE"
      local i
      for (( i=${#steps[@]}-1; i>=0; i-- )); do
        _undo_step "${steps[$i]}" || true
      done
      rm -f "$MANIFEST_FILE"
    fi
    log_error "Cleanup complete. See ${LOG_FILE} for details."
  else
    _print_summary
  fi
}
trap cleanup EXIT

# ── Undo dispatcher ────────────────────────────────────────────────────────────
_undo_step() {
  local entry="$1"
  local type="${entry%%:*}"
  local payload="${entry#*:}"
  case "$type" in
    file)
      if [[ -f "$payload" ]]; then
        rm -f "$payload"
        log_info "Removed: ${payload}"
      fi
      ;;
    hook)
      # Format: hook:pre-commit:/path/to/.git/hooks/pre-commit
      local hook_path="${payload#*:}"
      if [[ -f "$hook_path" ]]; then
        rm -f "$hook_path"
        log_info "Removed hook: ${hook_path}"
      fi
      ;;
    symlink)
      if [[ -L "$payload" ]]; then
        rm -f "$payload"
        log_info "Removed symlink: ${payload}"
      fi
      ;;
    *)
      log_warn "Unknown manifest entry type '${type}' — skipping undo for: ${entry}"
      ;;
  esac
}

# ── Summary printer ────────────────────────────────────────────────────────────
_print_summary() {
  echo ""
  log_step "Bootstrap Complete"
  if [[ ${#_SUMMARY_INSTALLED[@]} -gt 0 ]]; then
    log_success "Installed:"
    for item in "${_SUMMARY_INSTALLED[@]}"; do
      echo "    ✓ ${item}"
    done
  fi
  if [[ ${#_SUMMARY_SKIPPED[@]} -gt 0 ]]; then
    log_info "Skipped (already present):"
    for item in "${_SUMMARY_SKIPPED[@]}"; do
      echo "    - ${item}"
    done
  fi
  if [[ ${#_SUMMARY_WARNINGS[@]} -gt 0 ]]; then
    log_warn "Warnings:"
    for item in "${_SUMMARY_WARNINGS[@]}"; do
      echo "    ! ${item}"
    done
  fi
}

# ── Root check ─────────────────────────────────────────────────────────────────
os_require_root

# ── Architecture detection ─────────────────────────────────────────────────────
ARCH="$(os_detect_arch)"
export ARCH
log_step "Starting bootstrap (arch: ${ARCH}, dry-run: ${DRY_RUN})"
log_info "Log file: ${LOG_FILE}"

# ── Phase scripts ──────────────────────────────────────────────────────────────
# Phase 1: Foundation (secret prevention)
# shellcheck source=scripts/install-gitleaks.sh
source "${DOTFILES_DIR}/scripts/install-gitleaks.sh"
install_gitleaks
install_pre_commit_hook
scan_git_history

# Future phases will be added here as they are implemented:
# Phase 2: Shell environment (source scripts/install-shell.sh)
# Phase 3: CLI tools and Docker (source scripts/install-tools.sh)
# Phase 4: Security hardening (source scripts/install-security.sh)

log_success "Bootstrap finished successfully."
```

**Note on `<YOUR_GITHUB_USER>`:** Use a placeholder string `<YOUR_GITHUB_USER>` in the DOTFILES_REPO URL. The user will replace this with their actual GitHub username before publishing. Do not hard-code a real URL.

**Note on dry-run invocation:** When piped via `curl | bash`, flags are passed as: `curl <url>/bootstrap.sh | bash -s -- --dry-run`. Document this in a comment at the top of the script.
  </action>
  <verify>
    bash -n bootstrap.sh && echo "bootstrap.sh: syntax OK"
    head -5 bootstrap.sh | grep "#!/usr/bin/env bash"
    grep "set -eEuo pipefail" bootstrap.sh
    grep "trap cleanup EXIT" bootstrap.sh
    grep "MANIFEST_FILE" bootstrap.sh
    grep "DRY_RUN" bootstrap.sh
    grep "os_detect_arch" bootstrap.sh
    grep "tee" bootstrap.sh
    chmod +x bootstrap.sh && ls -la bootstrap.sh | grep -E "^-rwx"
  </verify>
  <done>
    - bootstrap.sh exists at repo root, is executable (chmod +x), passes `bash -n`
    - Contains #!/usr/bin/env bash, set -eEuo pipefail, trap cleanup EXIT
    - Contains MANIFEST_FILE pointing to ~/.dotfiles/.installed
    - Contains DRY_RUN flag parsing
    - Contains os_detect_arch() call and ARCH export
    - Contains tee redirection for dual output
    - Contains _print_summary() that reports installed/skipped/warnings
    - Phase scripts stubbed in order with comments for future phases
  </done>
</task>

</tasks>

<verification>
Run from repo root:
1. `bash -n bootstrap.sh` — passes syntax check
2. `grep -c "set -eEuo pipefail" bootstrap.sh` — returns 1
3. `grep -c "trap cleanup EXIT" bootstrap.sh` — returns 1
4. `grep "MANIFEST_FILE" bootstrap.sh` — shows ~/.dotfiles/.installed
5. `grep "os_detect_arch" bootstrap.sh` — present
6. `ls -la bootstrap.sh` — shows executable bit set (-rwxr-xr-x or similar)
7. `bash -c 'source lib/log.sh; source lib/os.sh; source lib/pkg.sh; echo "libs OK"'` — succeeds (confirming bootstrap.sh's source chain would work)
</verification>

<success_criteria>
- bootstrap.sh at repo root, executable, passes bash -n
- All locked decisions implemented: verbose output via log.sh, --dry-run flag, fail-fast with trap cleanup EXIT, manifest-based rollback reading in reverse, ARCH detection via os_detect_arch, dual terminal+log output via tee, end-of-run summary
- No `read` or interactive prompts anywhere in the script
- No #!/bin/bash (must be #!/usr/bin/env bash)
- Phase script stubs present with comments for phases 2-4
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md` with:
- Confirmation of all locked decisions implemented
- Note the DOTFILES_REPO placeholder and where user must update it
- The full manifest entry format used (file:, hook:, symlink:) for future phases to reference
- Any deviations from the plan and why
</output>
