---
phase: 02-shell-environment-and-config-deployment
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/install-shell.sh
  - bootstrap.sh
autonomous: true
requirements: [SHELL-01, SHELL-02, SHELL-03, SHELL-04, SHELL-05, SHELL-06]

must_haves:
  truths:
    - "Running bootstrap.sh on a fresh server installs zsh, oh-my-zsh, starship, tmux, both zsh plugins, and deploys all four dotfiles as symlinks"
    - "zsh is set as the default shell for the target user (SUDO_USER or root) after bootstrap completes"
    - "oh-my-zsh install is guarded by directory existence check — installer is NOT re-run if ~/.oh-my-zsh already exists (installer exits 1 if dir exists)"
    - "Running bootstrap.sh a second time completes without error — all six install functions are idempotent"
    - "Pre-existing config files at $HOME are backed up to ~/.dotfiles.bak/ before symlinks overwrite them; timestamp suffix prevents collision"
  artifacts:
    - path: "scripts/install-shell.sh"
      provides: "Six functions: install_zsh, install_ohmyzsh, install_starship, install_tmux, install_zsh_plugins, deploy_dotfiles — all sourced by bootstrap.sh"
      exports: ["install_zsh", "install_ohmyzsh", "install_starship", "install_tmux", "install_zsh_plugins", "deploy_dotfiles"]
      min_lines: 120
    - path: "bootstrap.sh"
      provides: "Phase 2 section that sources install-shell.sh and calls all six functions in correct order"
      contains: "source.*install-shell.sh"
  key_links:
    - from: "bootstrap.sh"
      to: "scripts/install-shell.sh"
      via: "source ${DOTFILES_DIR}/scripts/install-shell.sh"
      pattern: "source.*install-shell\\.sh"
    - from: "install_zsh"
      to: "/etc/shells"
      via: "grep -qF zsh_path /etc/shells || echo zsh_path >> /etc/shells before usermod"
      pattern: "/etc/shells"
    - from: "install_ohmyzsh"
      to: "~/.oh-my-zsh"
      via: "directory pre-check guard: if [[ ! -d ~/.oh-my-zsh ]]; then run installer"
      pattern: "oh-my-zsh"
    - from: "install_zsh_plugins"
      to: "${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/"
      via: "git clone --depth 1 with directory existence guard"
      pattern: "git clone.*depth 1"
    - from: "deploy_dotfiles"
      to: "${DOTFILES_DIR}/dotfiles/"
      via: "_deploy_symlink calls ln -sfn src dst with backup-first logic"
      pattern: "ln -sfn"
---

<objective>
Create scripts/install-shell.sh — the Phase 2 installer script that provides six idempotent functions for the full shell stack installation — and wire it into bootstrap.sh.

Purpose: This is the executable layer that installs zsh + oh-my-zsh + starship + tmux + two plugins and deploys the four dotfiles from Plan 01 as symlinks into $HOME. After bootstrap runs, the server has a fully configured zsh environment.

Output: scripts/install-shell.sh with six sourced functions; bootstrap.sh updated to call them in correct sequence.
</objective>

<execution_context>
@/Users/elmartinez85/.claude/get-shit-done/workflows/execute-plan.md
@/Users/elmartinez85/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-shell-environment-and-config-deployment/02-CONTEXT.md
@.planning/phases/02-shell-environment-and-config-deployment/02-RESEARCH.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
@.planning/phases/01-foundation/01-03-SUMMARY.md
@bootstrap.sh
@scripts/install-gitleaks.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create scripts/install-shell.sh with all six installer functions</name>
  <files>scripts/install-shell.sh</files>
  <action>
Create `scripts/install-shell.sh` following the exact Phase 1 pattern established by `scripts/install-gitleaks.sh`. The script is sourced by bootstrap.sh (never executed directly), exports six functions, and uses the double-source guard convention.

**File header (matches install-gitleaks.sh pattern):**
```bash
#!/usr/bin/env bash
# scripts/install-shell.sh
# Sourced by bootstrap.sh — provides install_zsh, install_ohmyzsh, install_starship,
# install_tmux, install_zsh_plugins, deploy_dotfiles
# shellcheck source=lib/log.sh
# shellcheck source=lib/pkg.sh
if [[ -n "${_SCRIPT_INSTALL_SHELL_LOADED:-}" ]]; then return 0; fi
_SCRIPT_INSTALL_SHELL_LOADED=1
```

**Function 1: install_zsh** (SHELL-01)
- Call `pkg_install zsh` (uses lib/pkg.sh, handles DRY_RUN, idempotent via dpkg-query)
- Determine target user: `local target_user="${SUDO_USER:-root}"` — bootstrap runs as root; SUDO_USER is the real invoking user
- Get zsh path: `zsh_path="$(command -v zsh)"`
- Ensure zsh is in /etc/shells: `grep -qF "$zsh_path" /etc/shells || echo "$zsh_path" >> /etc/shells` — both usermod and chsh validate against /etc/shells; apt install zsh usually adds it but not guaranteed on all images
- Check if already default shell: `getent passwd "$target_user" | cut -d: -f7` — if already zsh, log_info and return 0 (add to _SUMMARY_SKIPPED)
- Change shell: `usermod -s "$zsh_path" "$target_user"` — NOT chsh; usermod modifies /etc/passwd directly and never prompts for PAM auth (chsh has PAM issues on RPi OS even as root)
- Log warning: "New shell takes effect on next login — start a new SSH session" (Pitfall 5: shell change does not take effect in current session; do NOT exec zsh here — bootstrap runs as root via sudo and mid-script shell switch causes issues with set -eEuo pipefail)
- Write to _SUMMARY_INSTALLED: `_SUMMARY_INSTALLED+=("zsh (default shell for ${target_user})")`

**Function 2: install_ohmyzsh** (SHELL-02)
CRITICAL: The oh-my-zsh official installer exits with error code 1 when ~/.oh-my-zsh already exists. The user's original locked decision ("re-run the installer — it handles existing installs gracefully") is INCORRECT and is overridden by this finding from the research. Use directory pre-check guard:

```bash
install_ohmyzsh() {
  log_step "Checking oh-my-zsh..."
  if [[ -d "${HOME}/.oh-my-zsh" ]]; then
    log_info "oh-my-zsh already installed (~/.oh-my-zsh exists) — skipping"
    _SUMMARY_SKIPPED+=("oh-my-zsh")
    return 0
  fi
  if [[ "${DRY_RUN:-false}" == "true" ]]; then
    log_info "[DRY RUN] Would install oh-my-zsh"
    return 0
  fi
  log_step "Installing oh-my-zsh (unattended)..."
  RUNZSH=no CHSH=no KEEP_ZSHRC=yes \
    sh -c "$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)"
  log_success "oh-my-zsh installed"
  echo "file:${HOME}/.oh-my-zsh" >> "$MANIFEST_FILE"
  _SUMMARY_INSTALLED+=("oh-my-zsh")
}
```

KEEP_ZSHRC=yes is required — without it the installer overwrites the existing .zshrc with its template (Pitfall 2). Since deploy_dotfiles deploys the repo's .zshrc as a symlink, the installer must not touch it.

**Function 3: install_starship** (SHELL-03)
- DRY_RUN guard first
- Run: `curl -fsSL https://starship.rs/install.sh | sh -s -- --yes`
- The official starship installer IS idempotent (overwrites existing binary) — re-run on every bootstrap is correct per user decision
- No directory pre-check needed (unlike oh-my-zsh)
- Write: `echo "file:/usr/local/bin/starship" >> "$MANIFEST_FILE"` (default install location)
- Append to _SUMMARY_INSTALLED

**Function 4: install_tmux** (SHELL-04)
- Simply: `pkg_install tmux` (uses lib/pkg.sh's idempotent dpkg-query wrapper — handles skip if already installed)
- Append to _SUMMARY_INSTALLED or _SUMMARY_SKIPPED based on whether pkg_install actually ran (pkg_installed check before calling pkg_install)
- Alternative: just call pkg_install and let pkg.sh handle it — pkg_install already logs "already installed" if dpkg-query confirms it

**Function 5: install_zsh_plugins** (SHELL-05, SHELL-06)
Both zsh-autosuggestions and zsh-syntax-highlighting. Clone into ${ZSH_CUSTOM:-${HOME}/.oh-my-zsh/custom}/plugins/ with --depth 1.

Use `${ZSH_CUSTOM:-${HOME}/.oh-my-zsh/custom}` (NOT hardcoded ~/.oh-my-zsh/custom) — anti-pattern in research.

For each plugin:
1. Directory existence guard: `if [[ -d "${plugins_dir}/zsh-autosuggestions" ]]; then skip; fi`
2. DRY_RUN guard
3. `git clone --depth 1 <url> <path>` — --depth 1 mandatory (zsh-syntax-highlighting repo is large; full clone is slow on RPi — Pitfall 6)
4. Write manifest entry, append to _SUMMARY_INSTALLED

URLs (from verified research sources):
- zsh-autosuggestions: `https://github.com/zsh-users/zsh-autosuggestions`
- zsh-syntax-highlighting: `https://github.com/zsh-users/zsh-syntax-highlighting`

**Function 6: deploy_dotfiles** (CONF-01, CONF-02, CONF-03, CONF-04)
Helper `_deploy_symlink src dst` and main `deploy_dotfiles` function.

`deploy_dotfiles`:
- Set `local dotfiles_dir="${DOTFILES_DIR}/dotfiles"` — DOTFILES_DIR is exported by bootstrap.sh as ~/.dotfiles (the cloned repo)
- `local backup_dir="${HOME}/.dotfiles.bak"` + `mkdir -p "$backup_dir"`
- Call _deploy_symlink for each of the four files:
  - `_deploy_symlink "${dotfiles_dir}/.zshrc"       "${HOME}/.zshrc"`
  - `_deploy_symlink "${dotfiles_dir}/.zsh_aliases" "${HOME}/.zsh_aliases"`
  - `_deploy_symlink "${dotfiles_dir}/.tmux.conf"   "${HOME}/.tmux.conf"`
  - `mkdir -p "${HOME}/.config"` then `_deploy_symlink "${dotfiles_dir}/starship.toml" "${HOME}/.config/starship.toml"`
  - Note: starship.toml target is ${HOME}/.config/starship.toml, NOT ${HOME}/starship.toml (Pitfall 4 — different from the other three)

`_deploy_symlink src dst`:
Case 1 — symlink already correct (readlink dst == src): log_info "already correct — skipping"; _SUMMARY_SKIPPED+=
Case 2 — real file (not a symlink) at dst: back it up
  - `local backup_path="${backup_dir}/${filename}"`
  - If backup already exists: `backup_path="${backup_dir}/${filename}.$(date +%Y-%m-%d)"` — timestamp suffix per locked decision
  - `mv "$dst" "$backup_path"`
  - Write `file:${backup_path}` to MANIFEST_FILE (so rollback can find and report it)
Case 3 — broken or stale symlink at dst: `rm -f "$dst"` before re-linking
Final: `ln -sfn "$src" "$dst"` — using -f (force) and -n (don't follow dir symlinks); write `symlink:${dst}` to MANIFEST_FILE; _SUMMARY_INSTALLED+=

Make the script executable: `chmod +x scripts/install-shell.sh`
  </action>
  <verify>
bash -n scripts/install-shell.sh
grep -q '_SCRIPT_INSTALL_SHELL_LOADED' scripts/install-shell.sh
grep -q 'install_zsh\b' scripts/install-shell.sh
grep -q 'install_ohmyzsh' scripts/install-shell.sh
grep -q 'install_starship' scripts/install-shell.sh
grep -q 'install_tmux' scripts/install-shell.sh
grep -q 'install_zsh_plugins' scripts/install-shell.sh
grep -q 'deploy_dotfiles' scripts/install-shell.sh
grep -q 'usermod -s' scripts/install-shell.sh
grep -q 'KEEP_ZSHRC=yes' scripts/install-shell.sh
grep -q '! -d.*oh-my-zsh' scripts/install-shell.sh
grep -q 'depth 1' scripts/install-shell.sh
grep -q 'ZSH_CUSTOM:-' scripts/install-shell.sh
grep -q 'ln -sfn' scripts/install-shell.sh
grep -q '\.dotfiles\.bak' scripts/install-shell.sh
grep -q 'date +%Y-%m-%d' scripts/install-shell.sh
grep -q '\.config/starship\.toml' scripts/install-shell.sh
wc -l scripts/install-shell.sh
  </verify>
  <done>scripts/install-shell.sh passes bash -n, has double-source guard, contains all six functions, uses usermod (not chsh), guards oh-my-zsh install with directory pre-check, uses --depth 1 for plugin clones, uses ${ZSH_CUSTOM:-...} for plugin path, _deploy_symlink handles backup with timestamp collision suffix, starship.toml targets $HOME/.config/starship.toml.</done>
</task>

<task type="auto">
  <name>Task 2: Wire Phase 2 into bootstrap.sh</name>
  <files>bootstrap.sh</files>
  <action>
Edit `bootstrap.sh` to replace the Phase 2 stub comment with the actual Phase 2 sourcing and function calls. The existing file has this stub at line ~141-142:

```bash
# Future phases will be added here as they are implemented:
# Phase 2: Shell environment (source scripts/install-shell.sh)
```

Replace the Phase 2 comment with the actual invocation block. The function call ORDER is critical — oh-my-zsh must be installed before plugins clone into its custom directory:

```bash
# Phase 2: Shell environment and config deployment
# shellcheck source=scripts/install-shell.sh
source "${DOTFILES_DIR}/scripts/install-shell.sh"
install_zsh
install_ohmyzsh
install_zsh_plugins
install_starship
install_tmux
deploy_dotfiles
```

Ordering rationale (document in a comment block in bootstrap.sh):
1. `install_zsh` — install zsh package + set default shell (must come first; all shell env depends on zsh)
2. `install_ohmyzsh` — install oh-my-zsh framework into ~/.oh-my-zsh (must come before plugins — plugins clone into ~/.oh-my-zsh/custom/plugins/)
3. `install_zsh_plugins` — clone zsh-autosuggestions and zsh-syntax-highlighting (requires ~/.oh-my-zsh/custom/plugins/ to exist from step 2)
4. `install_starship` — install starship binary (independent of oh-my-zsh; placed after plugins for logical grouping)
5. `install_tmux` — install tmux package (fully independent; can go anywhere after zsh is set up)
6. `deploy_dotfiles` — create symlinks last (dotfiles reference all the above; deploy after everything is installed)

Keep the Phase 3 and Phase 4 stub comments in place — only replace/expand the Phase 2 section. Do not touch any other part of bootstrap.sh.

After editing, verify: `bash -n bootstrap.sh` must pass.
  </action>
  <verify>
bash -n bootstrap.sh
grep -q 'source.*install-shell.sh' bootstrap.sh
grep -q 'install_zsh$' bootstrap.sh
grep -q 'install_ohmyzsh' bootstrap.sh
grep -q 'install_zsh_plugins' bootstrap.sh
grep -q 'install_starship' bootstrap.sh
grep -q 'install_tmux' bootstrap.sh
grep -q 'deploy_dotfiles' bootstrap.sh
# Confirm order: install_ohmyzsh appears before install_zsh_plugins
grep -n 'install_ohmyzsh\|install_zsh_plugins' bootstrap.sh
# Phase 3 and 4 stubs still present
grep -q 'Phase 3' bootstrap.sh
grep -q 'Phase 4' bootstrap.sh
  </verify>
  <done>bootstrap.sh passes bash -n, sources install-shell.sh and calls all six functions in correct order (install_zsh → install_ohmyzsh → install_zsh_plugins → install_starship → install_tmux → deploy_dotfiles). Phase 3 and Phase 4 stubs remain intact.</done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `bash -n scripts/install-shell.sh` exits 0
2. `bash -n bootstrap.sh` exits 0
3. `grep -c 'source.*install-shell.sh' bootstrap.sh` returns 1
4. All six functions defined in install-shell.sh: `grep -c '^\(install_zsh\|install_ohmyzsh\|install_starship\|install_tmux\|install_zsh_plugins\|deploy_dotfiles\)()' scripts/install-shell.sh` returns 6
5. oh-my-zsh guard present: `grep -q '! -d.*oh-my-zsh' scripts/install-shell.sh`
6. starship.toml target is .config path: `grep -q '.config/starship.toml' scripts/install-shell.sh`
7. Plugin clone uses depth 1: `grep -q 'depth 1' scripts/install-shell.sh`
8. usermod used (not chsh): `grep -q 'usermod' scripts/install-shell.sh && ! grep -q 'chsh' scripts/install-shell.sh`
</verification>

<success_criteria>
scripts/install-shell.sh provides six idempotent functions that bootstrap.sh calls in correct dependency order. A fresh server run installs the complete shell stack. A second run skips all already-installed components without error. Pre-existing dotfiles are backed up, never silently overwritten. The Phase 2 section of bootstrap.sh is wired; Phases 3 and 4 stubs remain for subsequent phases.
</success_criteria>

<output>
After completion, create `.planning/phases/02-shell-environment-and-config-deployment/02-02-SUMMARY.md`
</output>
