---
phase: 03-cli-tools-and-docker
plan: 04
type: execute
wave: 3
depends_on:
  - 03-02
  - 03-03
files_modified:
  - scripts/verify.sh
  - bootstrap.sh
autonomous: true
requirements:
  - TOOL-01
  - TOOL-02
  - TOOL-03
  - TOOL-04
  - TOOL-05
  - TOOL-06
  - TOOL-07
  - DOCK-01
  - DOCK-02
  - DOCK-03
  - DOCK-04

must_haves:
  truths:
    - "scripts/verify.sh exists and can be run by the operator after re-login to confirm all Phase 3 tools are correctly installed"
    - "verify.sh reports PASS/FAIL per tool and exits 0 only if all checks pass"
    - "verify.sh checks docker run hello-world (DOCK-01/02/03 combined test requiring re-login) and docker compose version"
    - "bootstrap.sh sources install-tools.sh and calls all seven CLI tool functions wrapped with _try_install"
    - "bootstrap.sh sources install-docker.sh and calls install_docker_engine, verify_docker_running, add_user_to_docker_group, install_lazydocker"
    - "bootstrap.sh Phase 3 comment block replaces the existing placeholder comment"
  artifacts:
    - path: "scripts/verify.sh"
      provides: "Operator post-relogin verification script"
      min_lines: 40
      contains: "docker run.*hello-world"
    - path: "bootstrap.sh"
      provides: "Bootstrap entrypoint with Phase 3 wiring"
      contains: "install-tools.sh"
  key_links:
    - from: "bootstrap.sh"
      to: "scripts/install-tools.sh"
      via: "source ${DOTFILES_DIR}/scripts/install-tools.sh"
      pattern: "source.*install-tools\\.sh"
    - from: "bootstrap.sh"
      to: "scripts/install-docker.sh"
      via: "source ${DOTFILES_DIR}/scripts/install-docker.sh"
      pattern: "source.*install-docker\\.sh"
    - from: "scripts/verify.sh"
      to: "lib/versions.sh"
      via: "source ${DOTFILES_DIR}/lib/versions.sh"
      pattern: "source.*lib/versions\\.sh"
---

<objective>
Create scripts/verify.sh (operator runs after re-login to confirm all Phase 3 tools work) and wire install-tools.sh and install-docker.sh into bootstrap.sh, replacing the existing placeholder comment.

Purpose: This plan is the integration step. Without bootstrap.sh wiring, Plans 02 and 03 produce scripts that are never called. Without verify.sh, there is no way for the operator to confirm DOCK-01/02/03 (which require docker group re-login) and tool version correctness after a full server bootstrap.

Output: scripts/verify.sh (~55 lines); bootstrap.sh updated with Phase 3 source + function calls replacing the placeholder comment.
</objective>

<execution_context>
@/Users/elmartinez85/.claude/get-shit-done/workflows/execute-plan.md
@/Users/elmartinez85/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/03-cli-tools-and-docker/03-CONTEXT.md
@.planning/phases/03-cli-tools-and-docker/03-RESEARCH.md
@bootstrap.sh
@.planning/phases/03-cli-tools-and-docker/03-02-SUMMARY.md
@.planning/phases/03-cli-tools-and-docker/03-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create scripts/verify.sh — operator post-relogin verification</name>
  <files>scripts/verify.sh</files>
  <action>
Create scripts/verify.sh. This script is NOT sourced by bootstrap.sh — it is run directly by the operator after a re-login (new SSH session) where the docker group membership is active.

Usage: `bash ~/.dotfiles/scripts/verify.sh`

The script must:
1. Source lib/versions.sh to get version strings (do NOT hardcode versions — must match what versions.sh defines so they stay in sync)
2. Define a check_binary helper function that tests binary presence + version match
3. Test all seven CLI tools
4. Test `docker run --rm hello-world` (no sudo — verifies DOCK-03 group membership)
5. Test `docker compose version` (verifies DOCK-02)
6. Test lazydocker binary (version check only — launching full TUI is not automatable)
7. Print PASS/FAIL per item with a final summary line
8. Exit 1 if any checks failed, exit 0 if all passed

**DOTFILES_DIR detection:** verify.sh may be run from any working directory. Use a path relative to the script itself:
```bash
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
DOTFILES_DIR="$(dirname "$SCRIPT_DIR")"
```

**Full implementation:**
```bash
#!/usr/bin/env bash
# scripts/verify.sh — Run after re-login to confirm Phase 3 is complete
# Usage: bash ~/.dotfiles/scripts/verify.sh
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
DOTFILES_DIR="$(dirname "$SCRIPT_DIR")"

# Source version store — do not hardcode versions here
# shellcheck source=lib/versions.sh
source "${DOTFILES_DIR}/lib/versions.sh"

PASS=0
FAIL=0

check_binary() {
  local name="$1"
  local version_cmd="$2"
  local expected_ver="$3"

  if ! command -v "$name" &>/dev/null; then
    echo "FAIL: ${name} not found in PATH"
    FAIL=$((FAIL + 1))
    return
  fi

  local ver
  ver="$(eval "$version_cmd" 2>/dev/null | head -1 || echo "unknown")"
  if [[ "$ver" == *"$expected_ver"* ]]; then
    echo "PASS: ${name} ${expected_ver}"
    PASS=$((PASS + 1))
  else
    echo "FAIL: ${name} version mismatch (got: ${ver}, want: ${expected_ver})"
    FAIL=$((FAIL + 1))
  fi
}

echo "==> Phase 3 Verification"
echo ""

# CLI tools
check_binary rg         "rg --version"         "$RIPGREP_VERSION"
check_binary fd         "fd --version"         "$FD_VERSION"
check_binary fzf        "fzf --version"        "$FZF_VERSION"
check_binary eza        "eza --version"        "$EZA_VERSION"
check_binary bat        "bat --version"        "$BAT_VERSION"
check_binary delta      "delta --version"      "$DELTA_VERSION"
check_binary nvim       "nvim --version"       "$NVIM_VERSION"

# Docker — requires docker group membership (re-login required)
echo ""
echo "==> Docker checks (require re-login for group membership)"

if docker run --rm hello-world &>/dev/null 2>&1; then
  echo "PASS: docker run hello-world (no sudo)"
  PASS=$((PASS + 1))
else
  echo "FAIL: docker run hello-world failed (did you re-login after bootstrap?)"
  FAIL=$((FAIL + 1))
fi

if docker compose version &>/dev/null 2>&1; then
  echo "PASS: docker compose version"
  PASS=$((PASS + 1))
else
  echo "FAIL: docker compose not available"
  FAIL=$((FAIL + 1))
fi

check_binary lazydocker "lazydocker --version" "$LAZYDOCKER_VERSION"

echo ""
echo "Results: ${PASS} passed, ${FAIL} failed"

[[ $FAIL -eq 0 ]]
```

Make the file executable: `chmod +x scripts/verify.sh`

Note: The `set -euo pipefail` at the top does not interfere with the PASS/FAIL accumulation because check_binary never exits non-zero — it increments FAIL instead. The final `[[ $FAIL -eq 0 ]]` provides the exit code for the script.
  </action>
  <verify>
bash -n scripts/verify.sh && echo "Syntax OK" && grep -c "check_binary\|docker run\|docker compose" scripts/verify.sh | xargs -I{} bash -c '[[ {} -ge 9 ]] && echo "Sufficient checks present"'
  </verify>
  <done>
scripts/verify.sh exists, is executable, passes bash -n, sources lib/versions.sh, checks all 7 CLI tools + docker run hello-world + docker compose version + lazydocker. Uses version variables from versions.sh (not hardcoded). Exits 0 on all pass, 1 on any fail.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire Phase 3 scripts into bootstrap.sh</name>
  <files>bootstrap.sh</files>
  <action>
Update bootstrap.sh to source and call the Phase 3 install functions. Replace the existing placeholder comment block:

```
# Phase 3: CLI tools and Docker (source scripts/install-tools.sh)
# Phase 4: Security hardening (source scripts/install-security.sh)
```

With the following Phase 3 wiring (keep Phase 4 placeholder):

```bash
# Phase 3: CLI tools and Docker
# Ordering rationale:
#   1. install-tools.sh — seven CLI tools, each soft-failed via _try_install
#      (one bad binary download does not abort the entire bootstrap)
#   2. install-docker.sh — Docker Engine (hard-fail: required infrastructure),
#      then lazydocker (soft-fail: optional TUI tool)
# shellcheck source=scripts/install-tools.sh
source "${DOTFILES_DIR}/scripts/install-tools.sh"
_try_install install_ripgrep
_try_install install_fd
_try_install install_fzf
_try_install install_eza
_try_install install_bat
_try_install install_delta
_try_install install_nvim

# shellcheck source=scripts/install-docker.sh
source "${DOTFILES_DIR}/scripts/install-docker.sh"
install_docker_engine
verify_docker_running
add_user_to_docker_group
_try_install install_lazydocker

# Phase 4: Security hardening (source scripts/install-security.sh)
```

IMPORTANT: `install_docker_engine` is called WITHOUT `_try_install` — Docker Engine is core infrastructure. A failure to install Docker should abort bootstrap (set -eEuo pipefail will handle it). `install_lazydocker` IS wrapped in `_try_install` — it is a convenience TUI tool, not core infrastructure.

Use the Edit tool to make a precise replacement of just the placeholder block. Do not alter any other part of bootstrap.sh. Confirm the replacement by reading the file after editing and verifying the Phase 3 block is present and the Phase 4 placeholder remains.
  </action>
  <verify>
bash -n bootstrap.sh && grep -A 20 "Phase 3: CLI tools" bootstrap.sh | grep -c "_try_install\|install_docker_engine\|verify_docker_running\|add_user_to_docker_group"
  </verify>
  <done>
bootstrap.sh passes bash -n. The Phase 3 section sources install-tools.sh and calls all seven install functions via _try_install. It sources install-docker.sh and calls install_docker_engine (no _try_install), verify_docker_running, add_user_to_docker_group, and _try_install install_lazydocker. The Phase 4 placeholder comment remains intact.
  </done>
</task>

</tasks>

<verification>
1. `bash -n scripts/verify.sh` — no syntax errors
2. `bash -n bootstrap.sh` — no syntax errors
3. `grep "source.*install-tools.sh" bootstrap.sh` — present
4. `grep "source.*install-docker.sh" bootstrap.sh` — present
5. `grep "_try_install install_ripgrep" bootstrap.sh` — present
6. `grep "install_docker_engine$" bootstrap.sh` — present (no _try_install wrapper)
7. `grep "_try_install install_docker_engine" bootstrap.sh` — absent (Docker Engine not soft-failed)
8. `grep "source.*lib/versions.sh" scripts/verify.sh` — present (not hardcoded versions)
9. `grep "RIPGREP_VERSION\|FD_VERSION\|FZF_VERSION" scripts/verify.sh` — version vars used
10. `grep "docker run.*hello-world" scripts/verify.sh` — present
11. `grep "Phase 4" bootstrap.sh` — placeholder still present
</verification>

<success_criteria>
scripts/verify.sh exists, sources lib/versions.sh, tests all 7 CLI tools and 3 Docker items (hello-world, compose, lazydocker), exits 0 only on all pass. bootstrap.sh sources both Phase 3 scripts and calls all Phase 3 functions with correct soft-fail/hard-fail strategy. bash -n passes for both files.
</success_criteria>

<output>
After completion, create `.planning/phases/03-cli-tools-and-docker/03-04-SUMMARY.md`
</output>
